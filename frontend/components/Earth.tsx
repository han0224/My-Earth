import { Suspense, useEffect, useRef, useState } from "react";
import { Canvas, MeshProps, useFrame } from "@react-three/fiber";
import {
  useGLTF,
  Html,
  OrbitControls,
  Environment,
  ContactShadows,
  Stars,
} from "@react-three/drei";
import * as THREE from "three";
import styles from "../styles/Earth.module.css";
import { GLTF } from "three/examples/jsm/loaders/GLTFLoader";

// const Star = () => {
//   const [star, setStar] = useState<number[][]>([]);
//   const obj = new Array(300)
//     .fill(0)
//     .map(() => [
//       Math.random() * 8 - 4,
//       Math.random() * 8 - 4,
//       Math.random() * 8 - 4,
//     ]);
//   useEffect(() => {
//     console.log("earth useEffect", star, typeof star, obj, typeof obj);
//     setStar(obj);
//   }, []);

//   //materials.push( new THREE.MeshPhongMaterial( { color: 0x000000, specular: 0x666666, emissive: 0xff0000, shininess: 10, opacity: 0.9, transparent: true }
//   //materials[ materials.length - 2 ].emissive.setHSL( 0.54, 1, 0.35 * ( 0.5 + 0.5 * Math.sin( 35 * timer ) ) );
//   return (
//     <group dispose={null}>
//       {star.map((v, i) => (
//         <mesh scale={0.01} position={[v[0], v[1], v[2]]} key={i}>
//           <sphereGeometry args={[1, 1, 0.3, 50]} />
//           <meshStandardMaterial attach="material" />
//         </mesh>
//       ))}
//     </group>
//   );
// };

// 인터페이스 정의하기
interface ModelProps {
  position: Array<Number>;
}
type GltfResult = GLTF & {
  nodes: {
    "URF-Height_Lampd_Ice_0": THREE.Mesh;
    "URF-Height_watr_0": THREE.Mesh;
    "URF-Height_Lampd_0": THREE.Mesh;
  };
  materials: {
    Lampd_Ice: THREE.Material;
    watr: THREE.Material;
    Lampd: THREE.Material;
  };
};
const Model = (props: ModelProps) => {
  /*
  Auto-generated by: https://github.com/pmndrs/gltfjsx
  author: JasperTobias (https://sketchfab.com/JasperTobias)
  license: CC-BY-4.0 (http://creativecommons.org/licenses/by/4.0/)
  source: https://sketchfab.com/3d-models/lowpoly-earth-ce0cce9b528b47c7984bf0b2b600d705
  title: LowPoly Earth
  */
  const { nodes, materials } = useGLTF("/earth.gltf") as unknown as GltfResult;
  return (
    <group
      rotation={[-Math.PI / 2, 0, Math.PI]}
      {...props.position}
      dispose={null}
    >
      <mesh
        geometry={nodes["URF-Height_Lampd_Ice_0"].geometry}
        material={materials.Lampd_Ice}
      />
      <mesh
        geometry={nodes["URF-Height_watr_0"].geometry}
        material={materials.watr}
        material-roughness={0}
      />
      <mesh
        geometry={nodes["URF-Height_Lampd_0"].geometry}
        material={materials.Lampd}
        material-color="lightgreen"
      ></mesh>
    </group>
  );
};

const Earth = () => {
  const ref = useRef<THREE.Mesh>(null);
  useFrame(() => (ref.current!.rotation.y += 0.01));
  return (
    <mesh ref={ref}>
      <Model position={[0, 0, 0]} />
    </mesh>
  );
};

const Viewer = () => {
  const ref = useRef(null);

  return (
    <Canvas
      className={styles.earth}
      dpr={[1, 2]}
      camera={{ position: [5, 0, 0], fov: 50 }}
    >
      <ambientLight intensity={0.1} />
      <directionalLight position={[0, 3, 0]} color="#11E8BB" />
      <directionalLight position={[0, -3, -0.3]} color="#8200C9" />
      <Suspense fallback={null}>
        <Earth />
        {/* <Star /> */}
        <Stars
          radius={30}
          depth={10}
          count={300}
          factor={7}
          saturation={0}
          fade={true}
        />
        <Environment preset="city" />
      </Suspense>
      <OrbitControls
        ref={ref}
        rotateSpeed={0.2}
        minDistance={5}
        maxDistance={5}
      />
    </Canvas>
  );
};

export default Viewer;
